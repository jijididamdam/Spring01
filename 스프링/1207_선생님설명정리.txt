스프링 구조 암기 : DI, 컨테이너(객체관리)

* DI : Inject, autowired     //    컨테이너 : 객체관리  , 컨테이너 장점 : 싱글톤   ~ 싱글톤이 중요한 이유 ) 불필요한 청소를 해야하니까 스프링은 주입받아서 쓰는 방식을 사용함

1. 자바소스

2. 라이브러리관리 : 오라클 접속 하기 위해서 ~ porm.xml에서 라이브러리관리하는 것    ~ Mybatis관리하기 위해서 디펜던시 추가한 것 
   (Maven)             
		>>  for 오라클 접속 > 라이브러리 > porm.xml > dependency 추가        
   * 디펜던시 = 라이브러리
   * 프로젝트 2가지  )  디펜던시 설정, 톰캣   

3. web.xml : 한글 설정
	    역할 )     c     >      s      >     설정     >     servlet(spring)
			   tomcat	      web.xml           Controller
   			    요청

   * web   vs  was의 차이 알아두면 좋음

4. *-context.xml : 스프링이 구동 시에 객체를 미리 만들어놔라     ~  new 연산자 사용 안해도 spring이 여기서 만들어줌
      (설정파일)    여기서 사용하는 객체 : bean
   	          - 어떤 객체이고 하는 역할이 무엇인지, 의존 형성이 어떻게 되어 있는지 보아야 함
	          - run as할 때, 객체 만들어줌  >  run as하고 처음 볼 곳이 콘솔이다  ~ why? 객체 만들어졌는지 보아야함
	          scan : 지정된 패키지의 모든 소스 파일을 스캔해서 bean으로 만들어달라
	                  ex ) <context:component-scan base-package="com.groupone.controller"/> 
    * bean or scan

   ** 스캔 순서 : 서블릿context.xml > 루트context.xml  >  객체만들어서 컨테이너에 넣어줌   >  inject가 없다면 설정파일 봐야함
   
bean path 설정한거 기억하기 > 파일데이터 유틸가면 리소스라고 적혀있음 ~  @Resource(name = "uploadPath")

자바파일 위치는 최대한 건들지 않는 것이 좋음


----12/08---------------------------------------------------------------------------------------------------------------------------------------------------------

Git hub  - 홈페이지  ~ 원격터리포지터리(remote리포지터리) ~ Github은 원격    ~  내가 가진 리포지터리 ( Remote Repository )    


리모트 리포지터리 만들 때 프로젝트당 리포지터리 1개 만든다    
같은 성격이면 1개만 들어가고    ~  지금은 1개면 된다
연동될 또 다른 프로젝트 할거면 2개 ex ) 네이버 - 네이버 쇼핑 연동 같은 느낌이면 2개

local ) spring01, spring02                            spring01이 연동되어 있다.(이름은 일치하는게 좋음)
Github ) spring01


0. 소스트리 설치하기
1. Github에 원격 만들기
2. 중심 소스 먼저 올리기 ( 1명만 )   ~ 충돌가능성有



----------------------
깃허브<회원가입> - remote 리포지토리

깃 - 원격과 로컬의 소스를 올리고 내리고 하면서 소스관리, 형상관리, 버전관리

개발용컴퓨터, 지금 사용하는 컴퓨터에서 리포지터리를 만들어요 local 리포지토리
>> 생각하면서 깃을 만져야함

깃은 원격과 로컬의 폴더나 파일의 관리를 의미한다.

1. 오류를 범할 수 있는 것 : 깃이 자바의 프로젝트를 관리하는 것이라는 생각
   >> 원격에 저장소와 로켈이 있는 저장소를 매칭하여 관리하는 것     ~ ex ) 자바프로젝트의 폴더일 수도 있고, 하나의 폴더 있을 수도 있다.

2. 형상관리 : 일기 같은 경우는 크게 문제될 일은 없으나, 예를 들어 어제 한 코드로 돌리고 싶다  > 깃허브는 수정된 과정이 history남아 있어 이를 활용한다.

3. 버전관리 : 현재 운영중인 소스<실제로 서비스되는 소스>
                 + 기능을 하나 추가하고 싶다. 실제로 서비스되는 소스를 만질 수 있을까?    ~ 위험한 행동
                 버전관리 : v1.0 - 실제 서비스로 동작시키자
                 개발버전을 하나 만들자    v1.0 > v2.0을 준비하자
                <브랜치> 복사본을 하나 만든다고 생각한다. 원격에서 만든다.
                주의 ) 만약 로컬에서 개발한 프로젝트를 깃에 올려서 서비스를 실행한다.
		로컬에서 개발한 프로젝트와 서버에서 서비스되는 리포지토리와 소스가 같다.
                        깃허브(서버)에서 브랜치를 복사본을 만들었다. 개발이라는 이름으로 만들었다.
		이렇게 되면 로컬에서 기존에 개발한 프로젝트로 작업할 경우 오류가 나기 쉽다.
		로컬도 새로운 리포지토리(프로젝트)를 생성하여 별도로 작업을 하는 것이 좋다.

		remote			local
		서비스버전(master)		로컬에서 개발
		개발버전			로컬에서도 새로운 개발버전의 프로젝트를 생성

*브랜치는 버전관리를 위해서이다.


4. 흐름을 기억하겠다.
   일반적으로 이런 방식으로 사용해라.
   깃허브는 소스를 저장하고 합치는 곳,   깃허브에서 소스를 수정이 가능하지만 이건 나중에 하고, 지금은 로컬은 소스를 수정하고 만드는 곳

5. 용어
   로컬 : add > commit > push
           - add : 깃허브에 올릴 파일을 선택한다.
           - commit : 메모를 남긴다. 한글이나 파워포인트 작성할 때 중간중간 저장할 때를 생각해보아라 주기가 있을 것이다.
		 너무 많이 남겨도 좋지만,,, 하루에 한 개나 두 개정도가 적당.  
		 ~ ex ) 내가 오늘 로그인 기능을 로컬에서 완성하고 이제 페이징을 해야한다.
		         오늘의 과제라면 커밋을 2번정도가 정당하다   ... 로그인 기능 완성일 때 & 페이징 기능 완성일 때,,메모를 남긴다.
	<* 이때까지 수정된 소스의 위치는 어디일까요? 소스의 위치는 local입니다. >
            - push : 커밋한 메모와 add한 파일이 github로 올라간다.
            <* 이렇게 되면 로컬의 소스가 원격으로 올라간다. >
            
	+ pull : 원격의 소스를 내가 다운로드 받는 것이다.
	          내가 지금 작업하고 있는 프로젝트의 파일이 변화가 있을 수 있다.
	          이 변화가 로컬에서 변화가 있어서 원격으로 업로드 하고 싶다   >> push
	          원격에서 변화된 프로젝트 파일이 로컬에 반영이 되지 않은 경우 >> pull 
		** 오류를 방지하기 위해서는 작업하기 전에 pull로 먼저 댕겨 오는 것이 좋다.


설치해야 할 프로그램 : 1. 소스트리 2. 깃허브 가입
1. 소스트리 : 원격에 다가 리포지토리 만들겠다.

머지작업 : 브랜치 나누어져서 버전관리 했던 소스들 합치기

















