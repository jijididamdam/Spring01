MVC2 
 - 지금까지 개발한 방식 - 동기방식 통신
 - 클라이언트 요청   서버의 처리(MVC 패턴)

 - 서블릿으로 컨트롤러를 정의했고 코딩
 - Model : DAO & DTO
 - View : html,css,js,jsp( 기본 문법, el표기법, jstl ) ~ jstl은 스프링에서 사용할 예정

 ex ) 회원 전체보기 기능을 구현하고 있다.
       클라이언트 요청 어떻게 할 것인가?

       컨트롤러 처리 어떻게 할 것인가?
        > 파라미터 받을 것인가?
        > 데이터베이스에서 자료를 가져와야 하는가?
        > 가져온 자료를 뷰에게 전달해야 하는가?
        > 전달하는 자료는 어떤 자료형인가? 원시타입, 객체, 리스트, map

       뷰에서는 어떻게 할 것인가? 클라이언트에게 제공할 화면을 정의를 하고 만든다.
        > 기본 html, css로 정적인 문서를 구현
        > 컨트롤러에게 받은 자료를 출력 ( el, jstl )
        > 클라이언트에게 js, jquery 등으로 동적인 문서를 제공한다.
                                  - ajax( 비동기 방식 통신 (무조건은 아님, 동기로 쓸 수도 있음) ) 


* 동기방식 vs 비동기방식                ~ Tip ) 면접관이 ajax에 대한 질문을 한다면 동기와 비동기 방식 이해하고 있는지 보는 것  ~> 특징 포인트로 답하면 됨
  ~ 이해의 기준 : 클라이언트의 요청( 개발자가 정의 )
	          클라이언트가 동기방식으로 요청할 것인가? 비동기방식으로 요청을 할 것인가?
  + ) 동기와 비동기는 웹에서만 사용되는 이론이 아니라 통신에 대한 이론이다.

- 동기방식 : 요청을 한다. > 요청을 기다린다. > 응답이 오면 이 때 작업을 한다                               ex ) 번호표 뽑고 은행 업무 기다림 ( 이때, 직원은 한명 )
				                   오지 않으면 아무것도 안하고 기다린다.
                => 특징 포인트 : 직렬적으로 순차적으로 처리한다.
			  정확한 결과를 예측할 수 있다.
			  장점 : 설계가 편하다. ~ 동시에 처리하지 않다.  
			  단점 : 앞 작업의 결과가 있을 때까지 아무것도 못하고 대기하게 된다.
	
- 비동기방식 : 무조건 요청한다. > 응답을 기다리지도 않는다.                                                     ex ) 햄버거가게 ( 직원 여러명이 동시 업무 처리 ) 
	       => 요청하고 기다리지 않고 다른 작업을 한다, 응답이 안와도 상관없다.
	       => 특징 포인트 : 병렬적으로 처리한다.( 동시에 처리한다는 의미 )
			     장점 : 자원의 낭비가 덜하다.( 동시에 업무를 여러개 시킨다. )
			     단점 : 설계가 동기보다는 복잡하다.

- ex ) 게시글 등록에서  동기 vs 비동기 구분해보겠다.
        - 동기 방식 : 글을 모두 작성 후 서버에게 전송하고 등록되었다는 결과의 응답을 받아서 화면이 전체 리스트 보기로 바뀐다.(결과처리)  
		 ~ 만약, 서버에서 응답이 없다면 화면은 바뀌지 않는다.
        - 입력하면서 작성자가 등록된 작성자인지 서버와의 통신을 통해서 알아 보는 기능을 동기방식으로 할 수 도 있고 비동기방식으로도 할 수 있다.
          만약, 동기방식이라면 글쓰기 동작의 순서가 등록된 작성자 확인이 끝나야만 글 등록이 가능하다.
                                                                                           끝나면 화면 전체가 새로 고침이 된다.
                 비동기방식으로 한다면 글 등록 여부와 상관없이 등록된 작성자 확인의 동작이 요청될 수 있다.
	     즉, 서버와 통신하는 별도의 작업이 병렬적으로 생성이 되는 것이다.
                 본 작업을 글쓰기이고, 병렬작업으로 등록된 작성자 기능이 설계됨.
	     화면 전체가 새로고침을 하지 않고 html요소만 지정하여 변경할 수 있다.

- Q ) 선생님 비동기방식으로 등록된 작성자 확인 기능이 있는데 실제로 이 기능을 먼저 하지 않으면 글 등록할 때 작성자 등록여부 확인하세요라고 경고창이 뜬다면
       이건 동기 방식이 아닐까요?    ~  캡쳐 화면 보기
       A ) 동기 방식이라면 작성자 등록 여부 확인 버튼 누르면 전체 화면이 하얗게 변한 다음 기존으로 돌아오는데 이 때, 원래 작업 (입력한 값들)이 사라졌을 수 있다.
												   ~ 안사라지기 위해서는 따로 코드 추가
		        작성자 등록 여부 확인 버튼 누르면 서버로 갔다 온다. +  글 등록버튼 누르면 서버로 갔다 온다.

            비동기 방식이라면 기존의 화면을 유지한 상태로 등록 여부 확인을 하여 원래 작업 유지되어 있다.
			서버에게 요청 작성자를 파라미터로 보낼테니 중복여부 확인해줘
                		응답을 받아서 등록된 사용자라면 value=1로 바꾸는 코드를 해줘   ( 서버로 갔다 왔는지 확인만 하겠다. )

      A  선생님 답안 ) 글 등록 시, 등록된 작성자 확인 기능이 동기방식으로 이루어지는 것이 아니라
		   글 등록 시, 작업이 이루어졌는지만 확인하는 절차가 있을 가능성이 높다.
		   
		   두 동작을 동기방식으로 처리 : 등록여부확인 동기 방식으로 처리하고 글등록을 동기방식처리
		   두 동작을 동기방식과 비동기방식으로 처리 : 등록여부확인은 비동기 방식으로 처리해야 병렬적으로 처리해라
			 			          단, 글 등록 시 처리가 되었는지만 확인해라
		   * 사용자가 사용할 때는 같아 보이지만 내부적인 동작의 설계는 다르다.. 내부동작을 이해할 필요가 있다.
		     왜냐하면 비동기 방식이 아이중복체크, 등록여부확인에서만 사용되는 것이 아니기 때문이다.
		     우리의 목적은 동기방식과 비동기방식의 이해가 우선이고, 이를 활용하는 설계적 측면이다.

- 비동기 방식 구현 ex ) 인스타그램 좋아요, 댓글, 실시간 댓글 업그레이드, 글전체보기에서 제목 옆에 댓글 수 보여주기
- 화면의 로딩이 시간이 걸릴 경우는 동기보다는 비동기가 나을 수 있다.
  > 동기 방식이라면 화면이 보여주는 순서가 같을 것이고, 비동기라면 응답이 오는 순서대로 화면에 출력되니 매번 다를 수 있다.


* 어노테이션 @ : 쉽게 말해서 택배 파손주의 스티커를 붙혀서 택배기사님에게 알려드리는 것과 비슷한 의미
                      어노테이션은 소스를 컴파일하면 컴파일러에게 이런 역할을 하는 클래스다. 
	          또는 기능을 요구한다고 알려주면 컴파일러는 어노테이션을 보고 해당 포지션에 배치시킨다.
                      또는 원하는 기능을 해결해준다. 
	          ( @ 이걸 어노테이션이라고 함 , run as하는 과정이 컴파일해주는 것 )

스프링 이해 ex )
1. @WebServlet("/") 을 먼저 본다
2. HttpServlet을 본다
  ** 흐름순서 : 클라이언트 - 요청 -> 톰캣 -> 서블릿에서 처리    ~ 서블릿을 하나의 프레임워크라고 봐도 됨


* 컨트롤러가 어노테이션을 보고 컨트롤러인지 알고 객체를 알아서 만들어줌
* 객체를 프레임워크가 관리한다.   ~  객체를 관리한다라는 개념 : 기존 개발자 > 프레임워크가 알아서 해줌   
						        1. 객체를 내가 만든다.  2. 컨트롤러로 동작할 수 있도록 만든다
* 톰캣이 어떤 서비스를 요청하는지 알 수 있기 위해 컨트롤러가 필요함  

* IOC (제어의 역전?) : 프레임워크가 제어하는 것 ( 개발자가 직접 하는 것이 아니라 컨트롤러가 알아서 해주는 것)

* 컨테이너라는 곳에 컨트롤러 넣어줌 ( 객체 만들어줌 ) - @WebServlet("/이름")  ~  이름 겹치면 안됨(mapping 이름 겹침 x) ~ 이름을 보고 객체 만들어줌
  								       > 왜 중복을 불허할까?  프레임 워크가 객체를 관리해서( 개발자가 객체 관리 X )
	
* 서블릿 파일 만드는 것 자체가 프레임 워크 기능 빌려 쓰는 것 


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Key point ) 프레임워크의 장점과 단점을 이해하자

[ 컨트롤러 & 프레임 워크 ]
개발을 프레임워크 기반에서 개발을 한다. ~ 운영은 프레임워크가 한다. 개발자는 기능을 정의해준다.
예전 경험을 본다면 고객관리프로그램을 만들면 고객클래스정의, DAO, DTO 기능별로 만들었다.    >>  매니저 클래스를 만들었다.
									            이제는 ) 프레임워크에서는 매니저 클래스 역할을 해주겠다. 

개발의 주체가 개발자가 아니라 프레임워크 : IOC (Inversion of Control)

DI ( Dependency Injection ) : 의존성주입
 - 클래스에서 의존하는 객체가 있을 경우, 객체를 직접 만들지 않고 외부에서 객체의 주소를 주입받는 방식이다. 
 - 스프링에서는 클래스의 의존관계를 별도의 설정파일에서 설정하고 관리한다.

* 컨테이너 : 스프링에서 설정된 것에 의해 객체가 만들어지면 이 객체를 컨테이너에서 보관하고 소스에서 필요하면 주입받아서 사용한다.

@Autowired     :   컨테이너로부터 객체를 가져다줘   ~ 못가져온다면 객체가 없는 것 ~ 설정해주지 않아서 ( + 설정파일에 객체의 의존관계 설정 > 컨테이너에 저장함 )
private SqlSession sqlSession;      // id가  SqlSession   


ex ) 
class AAA{
	BBB b // BBB 객체가 필요
	
}

class BBB{

}

AAA클래스에서 b객체를 참조해야 한다. ( AAA클래스는 BBB 클래스를 의존한다. )
즉, AAA에 선언된 b라는 변수는 객체가 아니다. 참조변수이다. 현재, 이 참조변수는 객체의 주소가 없다. 
즉, AAA객체는 BBB객체를 의존하는데 실제 객체가 없다.
여기서 문제!!! b참조 변수가 객체의 주소를 저장하게 하는 방법은 3가지 정도가 있다.   ~  point ) 3가지 방법에 대한 특징을 이해한다면 DI를 이해할 수 있다.
                  1. AAA라는 클래스가 직접 객체를 생성하는 방법   ex ) BBB b = new BBB();    ~  필요하면 내가 만든다
	      2. 다른 클래스에서 BBB객체를 만들고 생성자로 주소를 전달해주는 경우         ~  필요하면 달라고 한다. (Spring - DI)
	      3. 다른 클래스에서 BBB객체를 만들고 setter로 주소를 전달해주는 경우          ~  필요하면 달라고 한다. (Spring - DI)



---------------------------------------------------------------------------------------------------------------------------------------------------------
[ Spring ]
프로그램 ) 
New - Spring Legacy Project - Spring MVC Project 클릭 - 프로젝트명입력 - 패키지명입력 - 완료

설명 )  ~ 캡쳐 참고
xml - 태그를 내가 정의하는 특징이 있음
        ~ 화면 설정을 어떻게 했는지만 우선 보아라
porm.xml  - aspectj: 관점지향형 프로그램
             - dependency : 디펜던시 단위로 라이브러리 정의한다.

web.xml  -  DispatcherServlet 이 요청부터 응답까지 처리해준다.
	-  <url-pattern>/</url-pattern>       ~        ex ) http://localhost:8099/cafe/
	-  시작점 DispatcherServlet > bean을 만든다 > <url-pattern> 정의해줌

HomeController.java  -  Model 변수명 :  응답할 때 자료를 보내는 객체이다.
		   -  return home;     ~  .jsp 생략됨  ~ servlet-context.xml 에서 지정해주었기 때문에
		   -  같은 이름이여도 method방식  ( get 과 post 방식 )이 다르면 에러 안남  


정리 )
1. 메이븐 디렉토리 구조 이해
2. 설정파일 이해 web.xml  root-context.xml   servlet-context.xml
3. MVC 설정 예   ~  클라이언트에서 컨트롤러 처리(요청처리) 뷰 응답까지의 순서를 먼저 이해하기
4. 클라이언트에서 파라미터 보내고 컨트롤러에서 받는 법
   가. 변수 하나 받기, 객체로 받기, json받기           ~   우리는 변수 하나 받기와 객체로 받기만 함
			       ( + json 자체가 (key,value)로 값을 받음  ~  Hashmap으로 받는다 )
       1. 변수 하나 받기  -  서블릿으로 받기, 어노테이션으로 받기
       2. 객체로 받기 - src/main/java > 패키지 > class 만들기 > public class 위에 @Controller 해주면 컨트롤러로 변함


-------------------------------------------------------------------------------------------------------------------------------
ex ) 
	@RequestMapping(value = "/wrAction", method = RequestMethod.POST)
	public String WrAction(Locale locale, Model model, BoardVO bvo) {
		//객체로 받을 때는 파라미터이름과 객체의 변수의 이름이 일치하고 getter, setter가 있어야 한다.  > 자동매핑
		System.out.println(bvo.getName());
		System.out.println(bvo.getEmail());
		
		return "wrForm";
	}

-------------------------------------------------------------------------------------------------------------------------------

실습 문제 )  출제 의도 : Spring에서 mvc 이해하기 
1. / 입력하면 메인화면이 출력된다. 메인 화면은
   <h1> 스프링 공부 </h1>
   메뉴는 홈으로 글쓰기 글보기

2. 글쓰기를 누르면 이름과 제목과 내용을 입력한다.
3. 등록 버튼을 누르면 컨트롤러에서 파라미터로 받고, wrchk.jsp에서 입력한 이름을 출력한다.
4. 한글이 가능하도록 연구하세요

> 프로젝트 새로 만들기 : Spring01_test
   컨트롤러는 / (루트)는 그대로 사용하고
   나머지는 새로 만든다.
.  컨트롤러에서 파라미터 받는 방법은 스스로 결정한다.


------------------------------------------------------------------------------------------------
한글 크롬에 보이기 : web.xml > <servlet-mapping> 밑에 적어주기

	<!-- 한글깨짐 방지 --> 
    <!-- filter와 filter-mapping을 만들어 준다. -->
    <filter> 
        <!-- filter안에는 filter-name, filter-class, init-param을 추가해 준다.
              filter-name은 원하는대로 지정해도됨 -->
        <filter-name>encodingFilter</filter-name> 
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param> 
            <!-- encoidng값을 UTF-8로 만들어 준다. -->
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
